

### Socket 网络编程

Socket，套接字就是两台主机之间逻辑连接的端点。TCP/IP协议是传输层协议，主要解决数据如何
在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。Socket是通信的基石，是支持TCP/IP协
议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信
息：连接使用的协议、本地主机的IP地址、本地进程的协议端口、远程主机的IP地址、远程进程的协议
端口。

### I/O模型说明

 -  BIO(同步并阻塞)
   1. 每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write
   2. 并发数较大时，需要创建大量线程来处理连接，系统资源占用较大
   3. 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费
 -  NIO(同步非阻塞)
   - 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理
 -  AIO(异步非阻塞)
   - AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用

#### BIO、NIO、AIO 适用场景分析

1. BIO(同步并阻塞) 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，
并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解
2. NIO(同步非阻塞) 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕
系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持
3. AIO(异步非阻塞) 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分
调用 OS 参与并发操作， 编程比较复杂，JDK7 开始支持。

#### NIO和 BIO的比较

1. BIO 以流的方式处理数据,而 NIO 以缓冲区的方式处理数据,缓冲区 I/O 的效率比流 I/O 高很多
2. BIO 是阻塞的，NIO则是非阻塞的
3. BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求， 数据到达等），因此使用单个线程就可以监听多个客户端通道

![三大核心原理示意图](030101.png)

#### 缓冲区对象添加数据

 - position: 获得当前要操作的索引
 - limit: 最多能操作到哪个索引
 - capacity: 返回缓冲区的总长度
 - remaining: 还有多少能操作索引个数

> 如果缓存区存满后, 可以调整position位置可以重复写,这样会覆盖之前存入索引的对应的值

![缓冲区对象添加数据](030102.png)

#### 缓冲区对象读取数据

 - flip(): 写切换读模式 limit设置position位置, position设置0
 - get(): 读一个字节
 - rewind(): 将position设置为0，可以重复读
 - clear(): 切换写模式 position设置为0 , limit 设置为 capacity
 - array(): 将缓冲区转换成字节数组返回（没写入的也会返回）

![图解:flip()方法](030103.png)

![图解:clear()方法](030104.png)

![练习](030105.png)

#### 通道(Channel)基本介绍

1. 通道可以读也可以写，流一般来说是单向的（只能读或者写，所以之前我们用流进行IO操作的时候需要分别创建一个输入流和一个输出流）
2. 通道可以异步读写
3. 通道总是基于缓冲区Buffer来读写

```java
package com.lagou.channel;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.nio.charset.StandardCharsets;
/**
* 客户端
*/
public class NIOClient {
  public static void main(String[] args) throws IOException {
    //1.打开通道
    SocketChannel socketChannel = SocketChannel.open();
    //2.设置连接IP和端口号
    socketChannel.connect(new InetSocketAddress("127.0.0.1", 9999));
    //3.写出数据
    socketChannel.write(ByteBuffer.wrap("老板, 该还钱拉!".getBytes(StandardCharsets.UTF_8)));
    //4.读取服务器写回的数据
    ByteBuffer readBuffer = ByteBuffer.allocate(1024);
    int read=socketChannel.read(readBuffer);  // 这里要等待 write 完
    System.out.println("服务端消息:" + new String(readBuffer.array(), 0, read,
    StandardCharsets.UTF_8));
    //5.释放资源
    socketChannel.close();
  }
}
```

#### Selector (选择器)基本介绍

![练习](030106.png)

##### 常用方法
 - SelectionKey.isAcceptable(): 是否是连接继续事件
 - SelectionKey.isConnectable(): 是否是连接就绪事件
 - SelectionKey.isReadable(): 是否是读就绪事件
 - SelectionKey.isWritable(): 是否是写就绪事件
##### SelectionKey中定义的4种事件:
 - SelectionKey.OP_ACCEPT —— 接收连接继续事件，表示服务器监听到了客户连接，服务器可以接收这个连接了
 - SelectionKey.OP_CONNECT —— 连接就绪事件，表示客户端与服务器的连接已经建立成功
 - SelectionKey.OP_READ —— 读就绪事件，表示通道中已经有了可读的数据，可以执行读操作了（通道目前有数据，可以进行读操作了）
 - SelectionKey.OP_WRITE —— 写就绪事件，表示已经可以向通道写数据了（通道目前可以用于写操作）



